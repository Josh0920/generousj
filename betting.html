<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>The Generous J Press — Betting</title>

  <style>
    :root{
      --bg:#ffffff;
      --ink:#0a0a0a;
      --muted:#5a5a5a;
      --rule:#eaeaea;
      --card:#ffffff;
      --shadow: 0 1px 2px rgba(0,0,0,.06), 0 6px 24px rgba(0,0,0,.06);
      --radius:16px;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--ink);font-family:var(--sans)}
    a{color:inherit;text-decoration:none}
    .wrap{max-width:1100px;margin:0 auto;padding:22px}
    header{display:flex;align-items:center;justify-content:space-between;margin-bottom:18px}
    .brand{font-weight:800;letter-spacing:-.2px}
    .tabs{display:flex;gap:10px}
    .tab{padding:8px 10px;border:1px solid var(--rule);border-radius:999px;font-size:13px;color:#111;background:#fff}
    .tab.active{background:#111;color:#fff;border-color:#111}

    .toprow{display:flex;gap:12px;flex-wrap:wrap;align-items:center;justify-content:space-between;margin:14px 0 18px}
    .search{flex:1;min-width:240px}
    .search input{
      width:100%;padding:12px 12px;border:1px solid var(--rule);border-radius:12px;font-size:14px;
      outline:none;
    }
    .filters{display:flex;gap:10px;flex-wrap:wrap}
    .select{
      padding:10px 10px;border:1px solid var(--rule);border-radius:12px;font-size:14px;background:#fff;
    }

    .grid{display:grid;grid-template-columns: 1.1fr .9fr;gap:16px}
    @media (max-width: 920px){ .grid{grid-template-columns:1fr} }

    .panel{
      background:var(--card);
      border:1px solid var(--rule);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .panel h2{
      margin:0;padding:14px 16px;border-bottom:1px solid var(--rule);
      font-size:14px;letter-spacing:.2px;text-transform:uppercase;color:#222;
    }

    /* Market list rows */
    .list{display:flex;flex-direction:column}
    .row{
      padding:14px 16px;
      display:grid;
      grid-template-columns: 1fr 120px;
      gap:14px;
      border-bottom:1px solid var(--rule);
    }
    .row:last-child{border-bottom:none}
    .q{font-size:15px;font-weight:650;line-height:1.25;margin-bottom:6px}
    .meta{display:flex;gap:10px;flex-wrap:wrap;font-size:12px;color:var(--muted)}
    .pill{border:1px solid var(--rule);border-radius:999px;padding:4px 8px;background:#fff}

    /* Prob bar */
    .bar{
      height:10px;border-radius:999px;background:#f3f3f3;overflow:hidden;margin-top:10px;border:1px solid #eee;
    }
    .bar > div{height:100%;background:#111;width:50%}

    /* YES/NO buttons */
    .actions{display:flex;gap:8px;justify-content:flex-end;align-items:flex-start}
    .btn{
      width:56px;
      border-radius:12px;
      border:1px solid var(--rule);
      background:#fff;
      padding:10px 0;
      font-weight:750;
      font-size:13px;
      cursor:pointer;
    }
    .btn:hover{border-color:#cfcfcf}
    .btn.primary{background:#111;color:#fff;border-color:#111}

    /* Right panel: selected market */
    .detail{padding:16px}
    .detail h3{margin:0 0 8px;font-size:18px;letter-spacing:-.2px}
    .detail .small{color:var(--muted);font-size:13px;margin-bottom:14px}
    .twoside{
      display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:10px
    }
    .bigbtn{
      border:1px solid var(--rule);border-radius:14px;background:#fff;padding:12px;
      display:flex;align-items:center;justify-content:space-between;cursor:pointer;
    }
    .bigbtn strong{font-size:14px}
    .bigbtn span{font-size:12px;color:var(--muted)}
    .bigbtn.primary{background:#111;color:#fff;border-color:#111}
    .bigbtn.primary span{color:#d9d9d9}

    .statline{display:flex;gap:12px;flex-wrap:wrap;margin-top:14px}
    .stat{border:1px solid var(--rule);border-radius:14px;padding:10px 12px;background:#fff}
    .stat .k{font-size:11px;color:var(--muted);text-transform:uppercase;letter-spacing:.2px}
    .stat .v{font-size:16px;font-weight:800;margin-top:2px}

    .notice{font-size:12px;color:var(--muted);margin-top:12px;line-height:1.35}

    /* Market graph */
    .chartWrap{
      margin-top:14px;
      border:1px solid var(--rule);
      border-radius:14px;
      overflow:hidden;
      background:#fff;
    }
    #chart{
      height:240px;
    }
    .chartTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 12px;
      border-bottom:1px solid var(--rule);
      font-size:12px;
      color:var(--muted);
    }
    .chartTop strong{color:#111}
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="brand"><a href="/">The Generous J Press</a></div>
      <nav class="tabs">
        <a class="tab" href="/">Home</a>
        <a class="tab active" href="/betting.html">Betting</a>
      </nav>
    </header>

    <div class="toprow">
      <div class="search">
        <input id="q" placeholder="Search markets (e.g., 'Trump', 'NFL', 'Florida College')" />
      </div>
      <div class="filters">
        <select id="category" class="select">
          <option value="">All categories</option>
          <option>Politics</option>
          <option>Sports</option>
          <option>Campus</option>
          <option>Entertainment</option>
          <option>World</option>
        </select>
        <select id="sort" class="select">
  <option value="newest" selected>Newest</option>
  <option value="closingSoon">Closing soon</option>
  <option value="mostVotes">Most votes</option>
</select>
      </div>
    </div>

    <div class="grid">
      <section class="panel">
        <h2>Markets</h2>
        <div id="list" class="list"></div>
      </section>

      <aside class="panel">
        <h2>Market</h2>
        <div class="detail" id="detail">
          <h3>Select a market</h3>
          <div class="small">Click any row to view it here and vote YES/NO.</div>
          <div class="notice">Tip: One vote per person.</div>
        </div>
      </aside>
    </div>
  </div>

  <!-- Supabase JS (no build tools needed) -->
  <script type="module">
    import { createClient } from "https://esm.sh/@supabase/supabase-js@2";
    import { createChart } from "https://cdn.jsdelivr.net/npm/lightweight-charts@4.1.3/+esm";

    // ✅ Your existing project info
    const SUPABASE_URL = "https://gyfoaukqsgbtcyxnmgvs.supabase.co";
    const SUPABASE_ANON_KEY = "sb_publishable__zVZ8qNWFakc7aA-K7SZjQ_o-biHbVB";

    const sb = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    const elList = document.getElementById("list");
    const elDetail = document.getElementById("detail");
    const elQ = document.getElementById("q");
    const elCategory = document.getElementById("category");
    const elSort = document.getElementById("sort");

    let markets = [];
    let selected = null;

    // ---- Market chart state ----
    let chart = null;
    let line = null;
    let resizeObs = null;

    // ---- Live vote subscription + incremental chart state ----
    let voteChannel = null;
    let seriesYes = 0;
    let seriesNo = 0;
    let lastSeriesTime = null;

    function destroyChart(){
      if (voteChannel){
        sb.removeChannel(voteChannel);
        voteChannel = null;
      }
      if (resizeObs) { resizeObs.disconnect(); resizeObs = null; }
      if (chart) { chart.remove(); chart = null; line = null; }
      seriesYes = 0;
      seriesNo = 0;
      lastSeriesTime = null;
    }

    function initChart(){
      const el = document.getElementById("chart");
      if (!el) return;

      chart = createChart(el, {
        width: el.clientWidth,
        height: el.clientHeight || 240,
        layout: { background: { type: "solid", color: "#ffffff" }, textColor: "#111" },
        grid: {
          vertLines: { color: "#eeeeee" },
          horzLines: { color: "#eeeeee" },
        },
        rightPriceScale: {
          borderColor: "#eeeeee",
          scaleMargins: { top: 0.15, bottom: 0.15 }
        },
        timeScale: {
  borderColor: "#eeeeee",
  timeVisible: true,
  secondsVisible: false,
  tickMarkFormatter: (time) => {
    const d = new Date(time * 1000);

    // Convert to EST
    const est = new Date(d.toLocaleString("en-US", { timeZone: "America/New_York" }));

    let h = est.getHours();
    const m = est.getMinutes().toString().padStart(2, "0");
    const ampm = h >= 12 ? "PM" : "AM";
    h = h % 12 || 12;

    return `${h}:${m} ${ampm}`;
  }
},
        crosshair: {
          vertLine: { color: "#cfcfcf", width: 1, style: 0 },
          horzLine: { color: "#cfcfcf", width: 1, style: 0 },
        }
      });

      line = chart.addLineSeries({
        color: "#111",
        lineWidth: 2,
        priceFormat: {
          type: "custom",
          minMove: 1,
          formatter: (p) => `${Math.round(p)}%`,
        },
      });

      // Keep chart responsive
      resizeObs = new ResizeObserver(() => {
        if (!chart) return;
        chart.applyOptions({ width: el.clientWidth, height: el.clientHeight || 240 });
      });
      resizeObs.observe(el);
    }

    function toUnixSeconds(d){
      return Math.floor(new Date(d).getTime() / 1000);
    }

    async function loadMarketSeries(marketId){
      // NOTE: if your votes table uses "inserted_at" instead of "created_at",
      // change this select() and the field used below.
      const { data, error } = await sb
        .from("votes")
        .select("created_at, side")
        .eq("market_id", marketId)
        .order("created_at", { ascending: true });

      if (error){
        console.error(error);
        return [];
      }

      const votes = data || [];
      if (!votes.length) return [];

      let yes = 0, no = 0;
      const points = [];

      for (const v of votes){
        if (v.side === "yes") yes++;
        else if (v.side === "no") no++;

        const total = yes + no;
        const pYes = total ? (yes / total) * 100 : 50;

        points.push({
          time: toUnixSeconds(v.created_at),
          value: pYes
        });
      }

      // De-duplicate identical timestamps (multiple votes same second)
      // Keep the last value for each time.
      const byTime = new Map();
      for (const pt of points) byTime.set(pt.time, pt.value);

      return Array.from(byTime.entries())
        .sort((a,b) => a[0] - b[0])
        .map(([time, value]) => ({ time, value }));
    }

    function pushVotePoint(vote){
      if (!line) return;

      if (vote.side === "yes") seriesYes++;
      else if (vote.side === "no") seriesNo++;

      const total = seriesYes + seriesNo;
      const pYes = total ? (seriesYes / total) * 100 : 50;

      let t = toUnixSeconds(vote.created_at || new Date().toISOString());

      // ensure strictly increasing times for visible ticks
      if (lastSeriesTime !== null && t <= lastSeriesTime) t = lastSeriesTime + 1;
      lastSeriesTime = t;

      line.update({ time: t, value: pYes });

      chart?.timeScale()?.scrollToRealTime();
    }

    function updateDetailStatsInPlace(){
      if (!selected) return;

      const p = pct(selected.yes_votes, selected.no_votes);

      // bar fill
      const barFill = document.querySelector('#detail .bar > div');
      if (barFill) barFill.style.width = `${p.yes}%`;

      // small % under YES/NO labels
      const yesSpan = document.querySelector('#voteYes span');
      const noSpan  = document.querySelector('#voteNo span');
      if (yesSpan) yesSpan.textContent = `${p.yes}%`;
      if (noSpan)  noSpan.textContent  = `${p.no}%`;

      // big right-side %
      const bigs = document.querySelectorAll('#detail .twoside .bigbtn div[style*="font-weight:900"]');
      if (bigs && bigs.length >= 2){
        bigs[0].textContent = `${p.yes}%`;
        bigs[1].textContent = `${p.no}%`;
      }

      // stats: Total, Yes, No
      const stats = document.querySelectorAll('#detail .stat .v');
      if (stats && stats.length >= 3){
        stats[0].textContent = `${p.t}`;
        stats[1].textContent = `${selected.yes_votes}`;
        stats[2].textContent = `${selected.no_votes}`;
      }
    }

    function startRealtimeForMarket(marketId){
      if (voteChannel){
        sb.removeChannel(voteChannel);
        voteChannel = null;
      }

      voteChannel = sb
        .channel(`votes-market-${marketId}`)
        .on(
          "postgres_changes",
          { event: "INSERT", schema: "public", table: "votes", filter: `market_id=eq.${marketId}` },
          (payload) => {
            const v = payload.new;

            // update chart instantly
            pushVotePoint(v);

            // update in-memory counters instantly (list + detail)
            const m = markets.find(x => String(x.id) === String(marketId));
            if (m){
              if (v.side === "yes") m.yes_votes = (Number(m.yes_votes) || 0) + 1;
              if (v.side === "no")  m.no_votes  = (Number(m.no_votes)  || 0) + 1;
            }

            if (selected && String(selected.id) === String(marketId)){
              // keep selected synced
              if (m) selected = m;

              // refresh list probabilities
              renderList();

              // refresh right-side stats without re-rendering chart
              updateDetailStatsInPlace();
            }
          }
        )
        .subscribe();
    }

    async function renderMarketChart(marketId){
      const el = document.getElementById("chart");
      if (!el) return;

      // IMPORTANT: detail HTML recreates #chart; must rebuild chart each market switch
      destroyChart();
      initChart();

      const series = await loadMarketSeries(marketId);

      // rebuild counts + last time (so live updates continue correctly)
      const { data: votes, error } = await sb
        .from("votes")
        .select("created_at, side")
        .eq("market_id", marketId)
        .order("created_at", { ascending: true });

      if (!error && votes && votes.length){
        seriesYes = 0; seriesNo = 0;
        for (const v of votes){
          if (v.side === "yes") seriesYes++;
          else if (v.side === "no") seriesNo++;
        }
        lastSeriesTime = toUnixSeconds(votes[votes.length - 1].created_at);
      } else {
        seriesYes = 0; seriesNo = 0;
        lastSeriesTime = series.length ? series[series.length - 1].time : null;
      }

      if (!series.length){
        const now = Math.floor(Date.now() / 1000);
        line.setData([{ time: now, value: 50 }]);
        chart.timeScale().fitContent();

        // ✅ SNAP even on empty series (overwrite last time point)
        const total = seriesYes + seriesNo;
        const pYesNow = total ? (seriesYes / total) * 100 : 50;
        const snapT = (lastSeriesTime !== null) ? lastSeriesTime : Math.floor(Date.now() / 1000);
        line.update({ time: snapT, value: pYesNow });
        lastSeriesTime = snapT;

        startRealtimeForMarket(marketId);
        return;
      }

      line.setData(series);
      chart.timeScale().fitContent();

      // ✅ SNAP: overwrite the LAST time point so the chart "last value" matches counters
      const total = seriesYes + seriesNo;
      const pYesNow = total ? (seriesYes / total) * 100 : 50;
      const snapT = (lastSeriesTime !== null) ? lastSeriesTime : Math.floor(Date.now() / 1000);
      line.update({ time: snapT, value: pYesNow });
      lastSeriesTime = snapT;

      startRealtimeForMarket(marketId);
    }

    function fmtEnds(iso){
      const end = new Date(iso);
      const now = new Date();
      const ms = end - now;
      if (isNaN(end.getTime())) return "—";
      if (ms <= 0) return "Closed";
      const hrs = Math.floor(ms/36e5);
      const days = Math.floor(hrs/24);
      if (days >= 2) return `${days}d`;
      return `${hrs}h`;
    }

    function pct(yes, no){
      const t = (yes||0)+(no||0);
      if (!t) return { yes: 50, no: 50, t: 0 };
      const y = Math.round((yes/t)*100);
      return { yes: y, no: 100-y, t };
    }

    function escapeHtml(s){
      return String(s ?? "")
        .replaceAll("&","&amp;").replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;").replaceAll("'","&#039;");
    }

    function renderList(){
      const q = elQ.value.trim().toLowerCase();
      const cat = elCategory.value.trim();
      const sort = elSort.value;

      let filtered = markets.filter(m => {
        const matchQ = !q || (m.title || "").toLowerCase().includes(q);
        const matchC = !cat || (m.category || "") === cat;
        return matchQ && matchC;
      });

      if (sort === "newest"){
        filtered.sort((a,b) => new Date(b.created_at) - new Date(a.created_at));
      } else if (sort === "mostVotes"){
        filtered.sort((a,b) => (b.yes_votes+b.no_votes) - (a.yes_votes+a.no_votes));
      } else { // closingSoon
        filtered.sort((a,b) => new Date(a.closes_at) - new Date(b.closes_at));
      }

      elList.innerHTML = filtered.map(m => {
        const p = pct(m.yes_votes, m.no_votes);
        return `
         <div class="row" id="market-${m.id}" data-id="${m.id}">
            <div>
              <div class="q">${escapeHtml(m.title)}</div>
              <div class="meta">
                <span class="pill">${escapeHtml(m.category || "General")}</span>
                <span>YES ${p.yes}%</span>
                <span>•</span>
                <span>${p.t} votes</span>
                <span>•</span>
                <span>Ends in ${fmtEnds(m.closes_at)}</span>
              </div>
              <div class="bar" title="YES probability">
                <div style="width:${p.yes}%;"></div>
              </div>
            </div>
            <div class="actions">
              <button class="btn primary" data-vote="yes">YES</button>
              <button class="btn" data-vote="no">NO</button>
            </div>
          </div>
        `;
      }).join("");

      // row click selects market; button click votes without selecting confusion
      elList.querySelectorAll(".row").forEach(row => {
        row.addEventListener("click", (e) => {
          const btn = e.target.closest("button");
          const id = row.getAttribute("data-id");
          if (!btn) selectMarket(id);
        });
        row.querySelectorAll("button").forEach(btn => {
          btn.addEventListener("click", async (e) => {
            e.preventDefault(); e.stopPropagation();
            const id = row.getAttribute("data-id");
            const side = btn.getAttribute("data-vote");
            await vote(id, side);
          });
        });
      });
    }

    function renderDetail(){
      if (!selected){
        elDetail.innerHTML = `
          <h3>Select a market</h3>
          <div class="small">Click any row to view it here and vote YES/NO.</div>
          <div class="notice">Tip: This is “voting” styled like a prediction market.</div>
        `;
        destroyChart();
        return;
      }
      const p = pct(selected.yes_votes, selected.no_votes);
      elDetail.innerHTML = `
        <h3>${escapeHtml(selected.title)}</h3>
        <div class="small">
          ${escapeHtml(selected.category || "General")} • Ends in <strong>${fmtEnds(selected.closes_at)}</strong>
        </div>

        <div class="chartWrap">
          <div class="chartTop">
            <div><strong>Market graph</strong> • YES implied probability</div>
            <div id="chartHint">updates with every vote</div>
          </div>
          <div id="chart"></div>
        </div>

        <div class="bar" title="YES probability">
          <div style="width:${p.yes}%;"></div>
        </div>

        <div class="twoside">
          <div class="bigbtn primary" id="voteYes">
            <div><strong>YES</strong><br><span>${p.yes}%</span></div>
            <div style="font-weight:900;">${p.yes}%</div>
          </div>
          <div class="bigbtn" id="voteNo">
            <div><strong>NO</strong><br><span>${p.no}%</span></div>
            <div style="font-weight:900;">${p.no}%</div>
          </div>
        </div>

        <div class="statline">
          <div class="stat"><div class="k">Total votes</div><div class="v">${p.t}</div></div>
          <div class="stat"><div class="k">Yes votes</div><div class="v">${selected.yes_votes}</div></div>
          <div class="stat"><div class="k">No votes</div><div class="v">${selected.no_votes}</div></div>
        </div>

        <div class="notice">
          One vote per person.
        </div>
      `;

      document.getElementById("voteYes").onclick = () => vote(selected.id, "yes");
      document.getElementById("voteNo").onclick = () => vote(selected.id, "no");

      renderMarketChart(selected.id);
    }

    function selectMarket(id){
      selected = markets.find(m => String(m.id) === String(id)) || null;
      renderDetail();
    }

    // Anonymous “one vote per browser per market” using localStorage key
    function votedKey(marketId){ return `gjp_vote_${marketId}`; }

    async function vote(marketId, side){
      const m0 = markets.find(x => String(x.id) === String(marketId));
      if (m0?.closes_at){
        const end = new Date(m0.closes_at);
        if (!isNaN(end.getTime()) && end.getTime() <= Date.now()){
          alert("This market is closed.");
          return;
        }
      }

      // prevent repeats per browser
      if (localStorage.getItem(votedKey(marketId))){
        alert("You already voted on this market from this browser.");
        return;
      }

      // record vote row
      const payload = {
        market_id: marketId,
        side: side,
        // optional: browser fingerprint-ish id
        voter_hash: getOrMakeVoterHash()
      };

      const { error: voteErr } = await sb.from("votes").insert(payload);
      if (voteErr){
        console.error(voteErr);
        alert("Vote failed. Check your Supabase RLS policies.");
        return;
      }

      // increment market counters (best-effort: read latest counters, then update)
      const field = side === "yes" ? "yes_votes" : "no_votes";

      const { data: cur, error: curErr } = await sb
        .from("markets")
        .select("yes_votes,no_votes")
        .eq("id", marketId)
        .single();

      if (curErr){
        console.error(curErr);
        alert("Vote recorded, but counter refresh failed. (Check RLS on markets select.)");
        return;
      }

      const nextVal = (Number(cur?.[field] ?? 0) || 0) + 1;

      const { error: updErr } = await sb
        .from("markets")
        .update({ [field]: nextVal })
        .eq("id", marketId);

      if (updErr){
        console.error(updErr);
        alert("Vote recorded, but counter update failed. (You can recompute totals later.)");
      } else {
        localStorage.setItem(votedKey(marketId), "1");
      }

      await loadMarkets(true);
      // chart updates via realtime INSERT; no need to rebuild here
    }

    function getOrMakeVoterHash(){
      let v = localStorage.getItem("gjp_voter_hash");
      if (!v){
        v = crypto.randomUUID();
        localStorage.setItem("gjp_voter_hash", v);
      }
      return v;
    }

    async function fetchMarkets(){
      const { data, error } = await sb
        .from("markets")
        .select("id,title,category,closes_at,yes_votes,no_votes,created_at")
        .order("created_at", { ascending: false });

      if (error){
        console.error(error);
        return [];
      }

      return (data || []).map(m => ({
        id: m.id,
        title: m.title || "",
        category: m.category || "General",
        closes_at: m.closes_at,
        created_at: m.created_at,
        updated_at: m.updated_at ?? m.created_at, // ✅ fallback so other code can still use updated_at safely
        yes_votes: Number(m.yes_votes ?? 0) || 0,
        no_votes: Number(m.no_votes ?? 0) || 0
      }));
    }

    async function loadMarkets(keepSelection=false){
      const data = await fetchMarkets();

      markets = (data || []).map(m => ({
        ...m,
        yes_votes: m.yes_votes || 0,
        no_votes: m.no_votes || 0
      }));

      if (!markets.length){
        elList.innerHTML = `<div style="padding:16px;color:#666;">No markets found yet. (If you just created one, check your RLS policies for markets.)</div>`;
        selected = null;
        renderDetail();
        return;
      }

      renderList();

      if (keepSelection && selected){
        const still = markets.find(m => String(m.id) === String(selected.id));
        selected = still || null;
      } else if (!selected && markets[0]) {
        selected = markets[0];
      }
      renderDetail();
    }

    // events
    [elQ, elCategory, elSort].forEach(el => el.addEventListener("input", renderList));
elSort.value = "newest";
await loadMarkets();
  </script>
</body>
</html>
